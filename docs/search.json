[
  {
    "objectID": "webarch.html#lecture",
    "href": "webarch.html#lecture",
    "title": "2  Web architecture",
    "section": "2.1 Lecture",
    "text": "2.1 Lecture\nSlides can be downloaded here"
  },
  {
    "objectID": "webarch.html#lab-what-do-apis-actually-do",
    "href": "webarch.html#lab-what-do-apis-actually-do",
    "title": "2  Web architecture",
    "section": "2.2 Lab: What do APIs actually do?",
    "text": "2.2 Lab: What do APIs actually do?\nIn this lab, we will unpack how Application Programming Interfaces (“APIs”) work and we cover the basics of accessing an API using R. Instead of downloading a data set, APIs allow programmers, statisticians (or students) to request data directly from a server to a local machine. When you work with web APIs, two different computers — a client and server — will interact with each other to request and provide data, respectively.\n\n2.2.1 RESTful Web APIs are all around you.\nWeb APIs\n\nAllow you query a remote database over the internet\nTake on a variety of formats\nAdhere to a particular style known as Representation State Transfer or REST (in most cases)\nRESTful APIs are convenient because we use them to query database using URLs\n\nConsider a simple Google search:\n\nEver wonder what all that extra stuff in the address bar was all about? In this case, the full address is Google’s way of sending a query to its databases requesting information related to the search term liverpool top attractions.\n\nIn fact, it looks like Google makes its query by taking the search terms, separating each of them with a +, and appending them to the link https://www.google.com/#q=. Therefore, we should be able to actually change our Google search by adding some terms to the URL:\n\nLearning how to use RESTful APIs is all about learning how to format these URLs so that you can get the response you want.\n\n\n2.2.2 Group activity\nGet into groups of 5 or 6 students. Using your friend the internet, look up answers to the following questions. Each group will be assigned one question and quickly present their findings to discuss with the entire class.\n\nWhat is a URL and how can it help us query data? What is a response status and what are the possible categories?\nWhat is a GET request? How does a GET request work?\nWhat are API keys and how do you obtain them? What kinds of restrictions to they impose on users? Find an example of an API key, what does it look like?\n(For 2 groups) More and more APIs pop up every day. Do a bit of quick research and find 2 different examples of APIs that you would be interested in using. 2 groups, 2 or 3 APIs each.\n\n\n\n2.2.3 API R libraries\nThere are two ways to collect data through APIs in R:\nWriting our own API request. If there is no wrapper function is available, we have to write our own API request and format the response ourselves using R. This is tricky, but definitely doable.\nPlug-n-play packages. Many common APIs are available through user-written R Packages. These packages offer functions that “wrap” API queries and format the response. These packages are usually much more convenient than writing our own query, so it is worth searching around for a package that works with the API we need.\n\n2.2.3.1 Our own API request\nThe R libraries that are often used for APIs are httr and jsonlite. They serve different roles in our introduction of APIs, but both are essential.\nJSON stands for JavaScript Object Notation. While JavaScript is another programming language. JSON is useful because it is easily readable by a computer, and for this reason, it has become the primary way that data is transported through APIs. Most APIs will send their responses in JSON format. Using the jsonlite package, you can extract and format data into an R dataframe. JSON is a structure formatted with a key (for example, a variable name id) and a value (BikePoints_308). We used the function fromJSON to transform the API request content into a useable dataframe.\nWe will request the locations of all the hire bike stations in London from the Transport for London API. We use the GET function from httr package.\n\nlibrary(httr)\nlibrary(jsonlite)\n\n#key <- \"YOURKEY HERE\"\nrequest <- GET(\"https://api.tfl.gov.uk/BikePoint/\")\n# To create a GET request, we need to use the GET() function from the `httr` library. \n#The GET() function requires a URL, which specifies the server's address to which the request needs to be sent.\n# Here we request all the bike docking stations from the Transport for London API\n\n\nrequest # Examine output\n\nResponse [https://api.tfl.gov.uk/BikePoint/]\n  Date: 2023-01-24 00:12\n  Status: 200\n  Content-Type: application/json; charset=utf-8\n  Size: 2.16 MB\n\n\n\nrequest$status_code # The response status is 200 for a successful request\n\n[1] 200\n\n\nMost GET request URLs for API querying have three or four components:\n\nAuthentication Key/Token: A user-specific character string appended to a base URL telling the server who is making the query; allows servers to efficiently manage database access.\nBase URL: A link stub that will be at the beginning of all calls to a given API; points the server to the location of an entire database.\nSearch Parameters: A character string appended to a base URL that tells the server what to extract from the database; basically a series of filters used to point to specific parts of a database.\nResponse Format: A character string indicating how the response should be formatted; usually one of .csv, .json, or .xml.\n\n\nbikepoints <- jsonlite::fromJSON(content(request, \"text\")) # extract the dataframe\nnames(bikepoints) # Print the column names\n\n [1] \"$type\"                \"id\"                   \"url\"                 \n [4] \"commonName\"           \"placeType\"            \"additionalProperties\"\n [7] \"children\"             \"childrenUrls\"         \"lat\"                 \n[10] \"lon\"                 \n\nbikepoints$`Station ID` = as.numeric(substr(bikepoints$id, nchar(\"BikePoints_\")+1, nchar(bikepoints$id))) # create new ID\n\nAfter Block 3 Data architectures we will have revised spatial data forms and you will easily be able to map data that you have obtained through this API.\n\n## Create an sf object from longitude latitude\nlibrary(dplyr)\nlibrary(sf)\nlibrary(tmap)\n# create a sf object\nstations_df <- bikepoints %>% \n  sf::st_as_sf(coords = c(10,9))  %>%  # create pts from coordinates\n  st_set_crs(4326) %>%  # set the original CRS\n  relocate(`Station ID`) # set ID as the first column of the dataframe\n\n# plot bikepoints on a background map for more context\ntmap_mode(\"view\")\ntm_basemap() +\n  tm_shape(stations_df) +\n  tm_symbols(id = \"commonName\", col = \"red\", scale = .5)\n\n\n\n\n\n\n\n\n\n2.2.4 Pair activity - Plug-n-play packages\nMany R packages have been developed that “wrap” API queries and format the response. Lucky us! In Pairs, let’s have a look at tidycensus. To get started working with tidycensus, users should load the package along with the tidyverse package, and set you Census API key. A key can be obtained from http://api.census.gov/data/key_signup.html.\n\nlibrary(plyr)\nlibrary(tidycensus)\nlibrary(tidyverse)\nlibrary(sf)\n\ncensus_api_key(\"12efa59339e5a00a910f77f2e691309ae70e1d1b\") #replace this with your key"
  },
  {
    "objectID": "webarch.html#references",
    "href": "webarch.html#references",
    "title": "2  Web architecture",
    "section": "3.1 References",
    "text": "3.1 References\n\nBrief History of the Internet, by the Internet Society, is a handy (and free!) introduction to how it all came to be.\nHaklay, M., Singleton, A., Parker, C. 2008. “Web Mapping 2.0: The Neogeography of the GeoWeb”. Geography Compass, 2(6):2011–2039\nA blog post from Joe Morrison commenting on the recent change of licensing for some of the core software from Mapbox\nTerman, R., 2020. Computational Tools for Social Science"
  },
  {
    "objectID": "webarch.html",
    "href": "webarch.html",
    "title": "2  Web architecture",
    "section": "",
    "text": "3 An Example: New York City\nThe following example shows median household income from the 2016-2020 ACS for Census tracts in New York State:"
  },
  {
    "objectID": "webarch.html#searching-for-variables",
    "href": "webarch.html#searching-for-variables",
    "title": "2  Web architecture",
    "section": "2.3 Searching for variables",
    "text": "2.3 Searching for variables\nGetting variables from the US American Community Survey (ACS) 5-Year Data (2016-2020) requires knowing the variable ID - and there are thousands of these IDs across the different files. To rapidly search for variables, use the load_variables() function. The function takes two required arguments: the year of the Census or endyear of the ACS sample, and the dataset name, which varies in availability by year. For the ACS, use either “acs1” or “acs5” for the ACS detailed tables, and append /profile for the Data Profile and /subject for the Subject Tables. To browse these variables, assign the result of this function to a variable and use the View function in RStudio. An optional argument cache = TRUE will cache the dataset on your computer for future use.\n\nview_vars <- load_variables(2020, \"acs5\", cache = TRUE)\n\nview(view_vars)"
  }
]